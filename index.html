        <div id="staging-container">
                        <!-- Staging info will be dynamically generated here -->
                    </div>
                </div>
                
                <!-- Flight Data Recorder -->
                <div class="bg-gray-900/50 p-3 rounded-lg border border-gray-700">
                    <h2 class="text-lg font-bold text-cyan-400 mb-2 border-b border-gray-600 pb-1">FLIGHT DATA RECORDER</h2>
                    <div class="space-y-4">
                        <div>
                            <h3 class="text-sm text-center mb-1 text-gray-400">Altitude (m) vs. Time (s)</h3>
                            <canvas id="altitudeChart"></canvas>
                        </div>
                        <div>
                            <h3 class="text-sm text-center mb-1 text-gray-400">Velocity (m/s) vs. Time (s)</h3>
                            <canvas id="velocityChart"></canvas>
                        </div>
                    </div>
                </div>

                <!-- AI Mission Analysis (New Feature) -->
                <div class="bg-gray-900/50 p-3 rounded-lg border border-gray-700">
                    <h2 class="text-lg font-bold text-cyan-400 mb-2 border-b border-gray-600 pb-1">AI MISSION ANALYSIS</h2>
                     <button id="generate-report-button" class="w-full p-3 bg-purple-600 hover:bg-purple-500 rounded-lg font-bold transition-all duration-200 disabled:bg-gray-600 disabled:cursor-not-allowed" disabled>
                        GENERATE REPORT âœ¨
                     </button>
                     <p id="report-note" class="text-xs text-center text-gray-400 mt-2 hidden">The report can only be generated after the flight simulation has ended.</p>
                </div>

                <!-- Controls -->
                <div class="bg-gray-900/50 p-3 rounded-lg border border-gray-700">
                    <h2 class="text-lg font-bold text-cyan-400 mb-2 border-b border-gray-600 pb-1">CONTROLS</h2>
                    
                    <!-- Throttle -->
                    <div class="mb-4">
                        <label for="throttle-slider" class="block mb-1 text-sm">THROTTLE (<span id="throttle-value">0</span>%)</label>
                        <input type="range" id="throttle-slider" min="0" max="100" value="0" class="w-full">
                    </div>

                    <!-- Action Buttons -->
                    <div class="grid grid-cols-2 gap-3 mb-4">
                        <button id="ignition-button" class="w-full p-3 bg-green-600 hover:bg-green-500 rounded-lg font-bold transition-all duration-200 disabled:bg-gray-600 disabled:cursor-not-allowed">IGNITION</button>
                        <button id="stage-button" class="w-full p-3 bg-blue-600 hover:bg-blue-500 rounded-lg font-bold transition-all duration-200 disabled:bg-gray-600 disabled:cursor-not-allowed" disabled>STAGE</button>
                    </div>
                    
                    <!-- Engine Control -->
                    <div class="grid grid-cols-2 gap-3 mb-4">
                        <button id="engine-shutdown" class="w-full p-2 bg-orange-600 hover:bg-orange-500 rounded-lg font-bold transition-all duration-200 disabled:bg-gray-600 disabled:cursor-not-allowed" disabled>ENGINE CUT</button>
                        <button id="abort-button" class="w-full p-2 bg-red-600 hover:bg-red-500 rounded-lg font-bold transition-all duration-200 disabled:bg-gray-600 disabled:cursor-not-allowed" disabled>ABORT</button>
                    </div>
                    

                </div>                 <!-- Landing Control -->
                <div class="mb-4 bg-gray-900/50 p-3 rounded-lg border border-gray-700">
                    <label class="block mb-2 text-sm font-bold">LANDING</label>
                    <div class="space-y-2">
                        <label class="inline-flex items-center space-x-2">
                            <input type="checkbox" id="auto-land-checkbox" class="h-4 w-4" checked>
                            <span class="text-sm">Auto land on arrival</span>
                        </label>
                    </div>
                </div>
                
                 <!-- Simulation Control -->
                <div class="bg-gray-900/50 p-3 rounded-lg border border-gray-700">
                     <h2 class="text-lg font-bold text-cyan-400 mb-2 border-b border-gray-600 pb-1">SIMULATION</h2>
                     
                     <!-- Time Control -->
                     <div class="mb-3">
                        <label for="time-scale" class="block mb-1 text-sm">TIME SCALE (<span id="time-scale-value">1.0</span>x)</label>
                        <input type="range" id="time-scale" min="0.1" max="5" step="0.1" value="1" class="w-full">
                     </div>
                     
                     <!-- Camera Zoom -->
                     <div class="mb-3">
                        <label for="zoom-slider" class="block mb-1 text-sm">CAMERA ZOOM (<span id="zoom-value">1.0</span>x)</label>
                        <input type="range" id="zoom-slider" min="0.2" max="3" step="0.1" value="1" class="w-full">
                     </div>
                     
                     <div class="grid grid-cols-2 gap-3">
                        <button id="pause-button" class="w-full p-2 bg-yellow-600 hover:bg-yellow-500 rounded-lg font-bold transition-all duration-200">PAUSE</button>
                        <button id="reset-button" class="w-full p-2 bg-red-700 hover:bg-red-600 rounded-lg font-bold transition-all duration-200">RESET</button>
                     </div>


                </div>

            </div>
        </aside>

    </div>

    <script>
        
        document.addEventListener('DOMContentLoaded', () => {
        
const ROCKET_BLUEPRINTS = [


    {
        id: 'basic-test-rocket',
        name: 'Basic Test Rocket ðŸ§ª',
        description: 'A simple two-stage liquid-fueled rocket for suborbital tests.',
        payloadMass: 500,
        stages: [
            // Stage 1: Booster
            { name: 'Booster', dryMass: 1500, initialFuelMass: 10000, fuelCapacity: 10000, maxThrust: 800000, visualHeight: 50 },
            // Stage 2: Sustainer
            { name: 'Sustainer', dryMass: 800, initialFuelMass: 8000, fuelCapacity: 8000, maxThrust: 300000, visualHeight: 30 },
        ],
    },
    {
        id: 'heavy-lift',
        name: 'Heavy-Lift Vehicle ðŸ›°ï¸',
        description: 'A powerful rocket with extra stages for heavy payloads.',
        payloadMass: 5000, // The heavy payload mass
        stages: [
            // Stage 1: Solid Rocket Boosters (SRB)
            { name: 'SRB-L', dryMass: 2000, initialFuelMass: 15000, fuelCapacity: 15000, maxThrust: 1000000, visualHeight: 40 },
            // Stage 2: Core Stage
            { name: 'Core Stage', dryMass: 5000, initialFuelMass: 40000, fuelCapacity: 40000, maxThrust: 2000000, visualHeight: 80 },
            // Stage 3: Upper Stage
            { name: 'Upper Stage', dryMass: 1000, initialFuelMass: 12000, fuelCapacity: 12000, maxThrust: 500000, visualHeight: 35 },
        ],
        
    },
    
]; 

const MISSIONS = [
    { id: 'test', name: 'Test Flight', distanceMeters: null },
    { id: 'mercury', name: 'Mercury', distanceMeters: 9.1e10 },
    { id: 'venus', name: 'Venus', distanceMeters: 4.1e10 },
    { id: 'mars', name: 'Mars', distanceMeters: 2.25e11 },
    { id: 'jupiter', name: 'Jupiter', distanceMeters: 6.28e11 },
    { id: 'saturn', name: 'Saturn', distanceMeters: 1.2e12 },
    { id: 'uranus', name: 'Uranus', distanceMeters: 2.6e12 },
    { id: 'neptune', name: 'Neptune', distanceMeters: 4.3e12 },
]; 

let selectedRocketBlueprint = null; 
let selectedMissionTarget = null;

let customRocketStages = [];
           

            // --- DOM Elements ---
            const canvas = document.getElementById('simulationCanvas');
            const ctx = canvas.getContext('2d');
            const altitudeChartCtx = document.getElementById('altitudeChart').getContext('2d');
            const velocityChartCtx = document.getElementById('velocityChart').getContext('2d');

            // ... (rest of DOM element declarations)
            const altitudeValue = document.getElementById('altitude-value');
            const velocity = document.getElementById('velocity');
            const maxAltitude = document.getElementById('max-altitude');
            const thrust = document.getElementById('thrust');
            const twr = document.getElementById('twr');
            const totalMass = document.getElementById('total-mass');
            const apogee = document.getElementById('apogee');
            // Mission UI elements
            const missionNameEl = document.getElementById('mission-name');
            const missionDistanceEl = document.getElementById('mission-distance');
            const missionCoveredEl = document.getElementById('mission-covered');
            const missionRemainingEl = document.getElementById('mission-remaining');
            const missionBurnTimeEl = document.getElementById('mission-burn-time');
            const missionFuelSpentEl = document.getElementById('mission-fuel-spent');
            const missionStatusEl = document.getElementById('mission-status');
            const missionProgressEl = document.getElementById('mission-progress');
            const missionMarkersEl = document.getElementById('mission-markers');
            const timeElapsed = document.getElementById('time-elapsed');
            const statusLight = document.getElementById('status-light');
            const statusText = document.getElementById('status-text');
            const stagingContainer = document.getElementById('staging-container');
            const throttleSlider = document.getElementById('throttle-slider');
            const throttleValue = document.getElementById('throttle-value');
            const ignitionButton = document.getElementById('ignition-button');
            const stageButton = document.getElementById('stage-button');
            const resetButton = document.getElementById('reset-button');
            const messageDisplay = document.getElementById('message-display');
            
            // New control elements
            const engineShutdownButton = document.getElementById('engine-shutdown');
            const abortButton = document.getElementById('abort-button');

            const timeScaleSlider = document.getElementById('time-scale');
            const timeScaleValue = document.getElementById('time-scale-value');
            const zoomSlider = document.getElementById('zoom-slider');
            const zoomValue = document.getElementById('zoom-value');
            const pauseButton = document.getElementById('pause-button');            // Landing controls
            const autoLandCheckbox = document.getElementById('auto-land-checkbox');

            // New AI elements
            const reportModal = document.getElementById('report-modal');
            const closeReportModal = document.getElementById('close-report-modal');
            const reportContent = document.getElementById('report-content');
            const generateReportButton = document.getElementById('generate-report-button');
            const reportNote = document.getElementById('report-note');

            // --- Simulation Constants ---
            const G = 9.81; // Gravitational acceleration (m/s^2)
            // INCREASED: from 0.1 to 0.5 for better visual feedback.
            const PIXELS_PER_METER = 0.5; // Visual scaling 
            const NOSE_HEIGHT = 20; // Fixed height for the nose cone in pixels
            // Scale down interplanetary distances to be reachable in simulation while keeping ratios
            const MISSION_DISTANCE_DIVISOR = 1e7; // e.g., 91,000,000 km becomes ~9.1 km equivalent
            const SPACE_ALTITUDE = 100000; // meters, sky turns black above this

            // --- Gemini API Configuration ---
            const apiKey = "AIzaSyCeBvGbwkQhIepO56if0Rpu9NgUWWMz10E"
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

            // --- Simulation State ---
            let simState;
            let altitudeChart, velocityChart;

            function getDefaultSimState() {
                return {
                    running: false,
                    launched: false,
                    startTime: 0,
                    lastFrameTime: 0,
                    lastDataLogTime: 0,
                    
                    rocket: {
                        x: 0,
                        y: 0, // y-position in meters from ground
                        vx: 0, // velocity x in m/s
                        vy: 0, // velocity y in m/s
                        ax: 0, // acceleration x in m/s^2
                        ay: 0, // acceleration y in m/s^2
                        
                        currentStage: 0,
                        totalMass: 0, // kg
                        throttle: 0, // 0 to 1

                        engineShutdown: false,
                        
                        stages: [
                            // Added visualHeight for dynamic drawing
                            { name: 'SRB', dryMass: 1500, fuelMass: 10000, fuelCapacity: 10000, maxThrust: 800000, active: false, separated: false, visualHeight: 50 },
                            { name: 'S-I', dryMass: 2000, fuelMass: 25000, fuelCapacity: 25000, maxThrust: 1200000, active: false, separated: false, visualHeight: 40 },
                            { name: 'S-II', dryMass: 800, fuelMass: 8000, fuelCapacity: 8000, maxThrust: 300000, active: false, separated: false, visualHeight: 30 },
                        ],
                        
                        width: 30, // fixed width for visualization (increased for better visibility)
                        height: 0, // dynamic height (will be calculated)
                    },

                    camera: {
                        y: 0,
                        zoom: 1.0,
                    },
                    
                    simulation: {
                        timeScale: 1.0,
                        paused: false,
                        aborted: false,
                    },
                    
                    stats: {
                        maxAltitude: 0,
                        apogee: 0,
                    },
                    
                    messages: [],

                    flightData: {
                        time: [],
                        altitude: [],
                        velocity: [],
                        positions: [], // Store x,y positions for flight path
                    },

                    mission: {
                        name: 'Test Flight',
                        distanceMeters: null,
                        effectiveDistanceMeters: null,
                        distanceCoveredMeters: 0,
                        lostConnection: false,
                        arrived: false,
                        landing: {
                            autoEnabled: false,
                            state: 'none', // none|approach|countdown|auto|manual|landed
                            countdownEndTime: 0,
                        },
                        uncontrolled: false, // ballistic fall without control (atmospheric fuel-out)
                    },

                    crash: {
                        crashed: false,
                        explosionTime: 0,
                        particles: [],
                    },
                };
            }
            // ... after getDefaultSimState()

            // --- Custom Rocket Builder Functions ---

            function getCustomRocketData() {
                const stages = [];
                // Collect data from all dynamic stage inputs
                document.querySelectorAll('.custom-stage-group').forEach((group, index) => {
                    stages.push({
                        name: group.querySelector('.stage-name-input').value || `Stage ${index + 1}`,
                        dryMass: parseFloat(group.querySelector('.dry-mass-input').value) || 0,
                        initialFuelMass: parseFloat(group.querySelector('.fuel-mass-input').value) || 0,
                        fuelCapacity: parseFloat(group.querySelector('.fuel-capacity-input')?.value) || parseFloat(group.querySelector('.fuel-mass-input').value) || 0,
                        maxThrust: parseFloat(group.querySelector('.max-thrust-input').value) || 0,
                        visualHeight: parseFloat(group.querySelector('.visual-height-input').value) || 30, // Default height
                    });
                });

                return {
                    id: 'custom-rocket',
                    name: customRocketNameInput.value || 'Custom Vehicle',
                    description: 'User-defined custom vehicle.',
                    payloadMass: parseFloat(customPayloadMassInput.value) || 0,
                    stages: stages.filter(s => s.dryMass + s.initialFuelMass + s.maxThrust > 0).reverse(), // Stages are added top-down, but the simulation needs them bottom-up (Stage 1 is index 0). Reverse them on collection.
                };
            }

            /**
             * Analyzes the custom rocket's design and suggests a minimum throttle for liftoff.
             */
            async function analyzeRocketForTWR() {
                const rocketData = getCustomRocketData();

                if (rocketData.stages.length === 0) {
                    aiSuggestionText.innerHTML = '<span class="text-red-400">Error: Add at least one stage to analyze.</span>';
                    return;
                }
                
                analyzeRocketBtn.disabled = true;
                analyzeRocketBtn.textContent = "ANALYZING...";
                aiSuggestionText.innerHTML = '<svg class="animate-spin h-4 w-4 mr-1 inline-block text-cyan-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg> Calculating minimum liftoff throttle...';

                // Calculate the initial total mass for TWR calculation
                const initialTotalMass = rocketData.payloadMass + rocketData.stages.reduce((sum, s) => sum + s.dryMass + s.initialFuelMass, 0);
                const firstStageMaxThrust = rocketData.stages[0].maxThrust;
                
                const systemPrompt = "You are an aerospace TWR (Thrust-to-Weight Ratio) calculation expert. Your goal is to analyze the provided rocket data and determine the minimum safe throttle percentage required for liftoff (TWR > 1.1) using *only* the first stage. You must output the result as a JSON object, focusing on a clear recommendation.";
                
                const userQuery = `Analyze the following initial liftoff configuration. Initial Total Mass: ${initialTotalMass.toFixed(2)} kg. First Stage Max Thrust: ${firstStageMaxThrust.toFixed(0)} N. Gravitational acceleration (G) is 9.81 m/s^2. Provide the minimum safe throttle (TWR > 1.1) as a percentage (0-100), and a brief justification.`;

                const responseSchema = {
                    type: "OBJECT",
                    properties: {
                        requiredThrottlePercentage: { type: "NUMBER", description: "The minimum safe throttle as a percentage (0-100) needed for TWR > 1.1, rounded to the nearest integer." },
                        justification: { type: "STRING", description: "A concise sentence explaining the TWR calculation and recommendation." },
                    },
                    required: ["requiredThrottlePercentage", "justification"],
                };

                try {
                    const payload = {
                        contents: [{ parts: [{ text: userQuery }] }],
                        systemInstruction: { parts: [{ text: systemPrompt }] },
                        generationConfig: {
                            responseMimeType: "application/json",
                            responseSchema: responseSchema
                        }
                    };

                    const response = await exponentialBackoffFetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    const result = await response.json();
                    const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;
                    
                    if (!jsonText) {
                        throw new Error("Gemini API returned no text content.");
                    }

                    const report = JSON.parse(jsonText);
                    
                    const minThrottle = Math.min(100, Math.max(0, report.requiredThrottlePercentage));
                    
                    aiSuggestionText.innerHTML = `
                        <p class="text-white font-bold mt-2">Recommended Minimum Throttle: <span class="text-green-400">${minThrottle}%</span></p>
                        <p class="text-xs text-gray-500">${report.justification}</p>
                    `;

                } catch (error) {
                    aiSuggestionText.innerHTML = `<p class="text-red-400 text-sm">AI Analysis Failed: ${error.message}. Please check your API Key and rocket values.</p>`;
                    console.error("Gemini API Error for TWR:", error);
                } finally {
                    analyzeRocketBtn.disabled = false;
                    analyzeRocketBtn.textContent = "ANALYZE THRUST ðŸ§ ";
                }
            }
            function renderCustomStages() {
                customStagesContainer.innerHTML = '';
                
                // Stages are rendered from top-down for intuitive building (Upper Stage, Core Stage, Booster)
                customRocketStages.forEach((stage, index) => {
                    const stageIndex = customRocketStages.length - index; // 3, 2, 1
                    
                    const stageDiv = document.createElement('div');
                    stageDiv.className = "custom-stage-group p-4 bg-gray-700/50 rounded-lg border border-purple-600/50";
                    stageDiv.dataset.index = index;
                    
                    stageDiv.innerHTML = `
                        <div class="flex justify-between items-center mb-3 border-b border-gray-600 pb-2">
                            <h4 class="text-lg font-bold text-purple-400">STAGE ${stageIndex} <span class="text-sm text-gray-400">(${stage.name})</span></h4>
                            <button class="remove-stage-btn p-1 bg-red-600 hover:bg-red-500 rounded text-xs font-bold transition-all">REMOVE</button>
                        </div>
                        
                        <label class="block mb-2">
                            <span class="text-sm text-gray-400">Stage Name</span>
                            <input type="text" class="stage-name-input w-full mt-1 p-2 bg-gray-800 border border-gray-600 rounded text-white" value="${stage.name}" placeholder="Upper Stage" required>
                        </label>
                        <div class="grid grid-cols-2 gap-3">
                            <label class="block mb-2">
                                <span class="text-sm text-gray-400">Dry Mass (kg)</span>
                                <input type="number" class="dry-mass-input w-full mt-1 p-2 bg-gray-800 border border-gray-600 rounded text-white" value="${stage.dryMass}" min="10" required>
                            </label>
                            <label class="block mb-2">
                                <span class="text-sm text-gray-400">Fuel Mass (kg)</span>
                                <input type="number" class="fuel-mass-input w-full mt-1 p-2 bg-gray-800 border border-gray-600 rounded text-white" value="${stage.initialFuelMass}" min="0" required>
                            </label>
                            <label class="block mb-2">
                                <span class="text-sm text-gray-400">Fuel Capacity (kg)</span>
                                <input type="number" class="fuel-capacity-input w-full mt-1 p-2 bg-gray-800 border border-gray-600 rounded text-white" value="${stage.fuelCapacity ?? stage.initialFuelMass ?? stage.fuelMass ?? 0}" min="0" required>
                            </label>
                            <label class="block mb-2">
                                <span class="text-sm text-gray-400">Max Thrust (N)</span>
                                <input type="number" class="max-thrust-input w-full mt-1 p-2 bg-gray-800 border border-gray-600 rounded text-white" value="${stage.maxThrust}" min="1000" required>
                            </label>
                            <label class="block mb-2">
                                <span class="text-sm text-gray-400">Visual Height (px)</span>
                                <input type="number" class="visual-height-input w-full mt-1 p-2 bg-gray-800 border border-gray-600 rounded text-white" value="${stage.visualHeight}" min="10" max="100" required>
                            </label>
                        </div>
                    `;
                    customStagesContainer.appendChild(stageDiv);
                });
                
                // Add event listeners for dynamic elements
                document.querySelectorAll('.remove-stage-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const index = e.target.closest('.custom-stage-group').dataset.index;
                        customRocketStages.splice(index, 1);
                        renderCustomStages();
                    });
                });
                
                document.querySelectorAll('.custom-stage-group input').forEach(input => {
                    input.addEventListener('input', updateCustomStagesData);
                });
            }

            function updateCustomStagesData() {
                // Read all data back into the customRocketStages array
                customRocketStages = [];
                document.querySelectorAll('.custom-stage-group').forEach((group, index) => {
                    customRocketStages.push({
                        name: group.querySelector('.stage-name-input').value || `Stage ${customRocketStages.length - index}`,
                        dryMass: parseFloat(group.querySelector('.dry-mass-input').value) || 0,
                        initialFuelMass: parseFloat(group.querySelector('.fuel-mass-input').value) || 0,
                        fuelCapacity: parseFloat(group.querySelector('.fuel-capacity-input')?.value) || parseFloat(group.querySelector('.fuel-mass-input').value) || 0,
                        maxThrust: parseFloat(group.querySelector('.max-thrust-input').value) || 0,
                        visualHeight: parseFloat(group.querySelector('.visual-height-input').value) || 30,
                    });
                });
            }

            function addDefaultStage() {
                const stageIndex = customRocketStages.length + 1;
                // Add new stage to the *start* of the array so it appears at the *top* of the list (Upper Stage first)
                customRocketStages.unshift({
                    name: `New Stage ${stageIndex}`,
                    dryMass: 500,
                    initialFuelMass: 3000,
                    fuelCapacity: 3000,
                    maxThrust: 200000,
                    visualHeight: 30,
                });
                renderCustomStages();
            }
            
            // --- Initialization ---
            function init() {
                simState = getDefaultSimState();

                // Initialize mission from selection
                if (!selectedMissionTarget) selectedMissionTarget = MISSIONS[0];
                simState.mission.name = selectedMissionTarget.name;
                simState.mission.distanceMeters = selectedMissionTarget.distanceMeters;
                simState.mission.effectiveDistanceMeters = selectedMissionTarget.distanceMeters == null ? null : (selectedMissionTarget.distanceMeters / MISSION_DISTANCE_DIVISOR);
                simState.mission.distanceCoveredMeters = 0;
                simState.mission.lostConnection = false;
                simState.mission.arrived = false;
                simState.mission.uncontrolled = false;                // Initialize landing state. autoEnabled is controlled by the checkbox, which is checked by default in HTML.
                simState.mission.landing = { autoEnabled: !!autoLandCheckbox?.checked, state: 'none', countdownEndTime: 0 };

                // Load the stages and mass from the selected blueprint
                simState.rocket.stages = selectedRocketBlueprint.stages.map(s => {
                    const capacity = (typeof s.fuelCapacity === 'number' ? s.fuelCapacity : s.initialFuelMass);
                    const initial = Math.min(s.initialFuelMass || 0, capacity || 0);
                    return {
                        ...s, // Copy all properties from the blueprint
                        fuelCapacity: capacity,
                        fuelMass: initial, // Current fuel cannot exceed capacity
                        initialFuelMass: initial, // Preserve initial load as the starting fuel
                        active: false,
                        separated: false,
                    };
                });

                // Set the non-jettisonable payload mass
                simState.rocket.baseMass = selectedRocketBlueprint.payloadMass;

                // Compute total fuel capacity across all stages (maximum fuel to burn)
                simState.rocket.totalFuelCapacity = simState.rocket.stages.reduce((sum, s) => sum + (s.fuelCapacity ?? s.initialFuelMass ?? 0), 0);

                // Continue the rest of the original initialization
                simState.rocket.stages.forEach(s => { s.initialFuelMass = s.fuelMass; });
                calculateTotalMass();
                updateRocketVisualHeight(); // Calculate initial visual height
                updateUI();
                updateStagingUI();

                throttleSlider.value = 0;
                timeScaleSlider.value = 1;
                zoomSlider.value = 1;
                ignitionButton.disabled = false;
                stageButton.disabled = true; // Disable until launched
                engineShutdownButton.disabled = true;
                abortButton.disabled = true;
                generateReportButton.disabled = true; // Disable report until end of flight

                initCharts();
                resizeCanvas();
                requestAnimationFrame(gameLoop);
            }
            
            // Calculates the total visual height of the rocket based on unseparated stages
            function updateRocketVisualHeight() {
                const totalStageHeight = simState.rocket.stages
                    .filter(s => !s.separated)
                    .reduce((sum, stage) => sum + stage.visualHeight, 0);
                // Total height is sum of stage heights plus the fixed nose cone height
                simState.rocket.height = totalStageHeight + NOSE_HEIGHT; 
            }

            // --- Chart Initialization ---
            function createChartConfig(label, color) {
                return {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: label,
                            data: [],
                            borderColor: color,
                            backgroundColor: `${color}33`, // transparent version
                            borderWidth: 1.5,
                            fill: true,
                            pointRadius: 0,
                            tension: 0.3
                        }]
                    },
                    options: {
                        animation: false,
                        scales: {
                            x: { ticks: { color: '#9ca3af' }, grid: { color: '#4b5563' } },
                            y: { ticks: { color: '#9ca3af' }, grid: { color: '#4b5563' } }
                        },
                        plugins: { legend: { display: false } }
                    }
                };
            }

            function initCharts() {
                if(altitudeChart) altitudeChart.destroy();
                if(velocityChart) velocityChart.destroy();
                altitudeChart = new Chart(altitudeChartCtx, createChartConfig('Altitude', '#34d399'));
                velocityChart = new Chart(velocityChartCtx, createChartConfig('Velocity', '#60a5fa'));
            }


            // --- Game Loop ---
            function gameLoop(currentTime) {
                if (!simState.lastFrameTime) {
                    simState.lastFrameTime = currentTime;
                }
                const deltaTime = (currentTime - simState.lastFrameTime) / 1000 * simState.simulation.timeScale; // in seconds with time scale

                if (simState.running && !simState.simulation.paused) {
                    updatePhysics(deltaTime);
                }

                draw();
                updateUI();
                
                simState.lastFrameTime = currentTime;
                requestAnimationFrame(gameLoop);
            }

            // --- Physics Engine ---
            function totalRemainingFuelMass() {
                return simState.rocket.stages.filter(s => !s.separated).reduce((sum, s) => sum + Math.max(0, s.fuelMass), 0);
            }

            function remainingBurnTimeSec(throttle) {
                const thr = Math.max(0, throttle);
                if (thr <= 0) return 0;
                let total = 0;
                simState.rocket.stages.forEach(s => {
                    if (!s.separated && s.fuelMass > 0 && s.maxThrust > 0) {
                        const mflow = (s.maxThrust / 5000) * thr;
                        total += s.fuelMass / mflow;
                    }
                });
                return total; // seconds across all remaining stages sequentially
            }

            function formatSeconds(sec) {
                if (!isFinite(sec) || sec <= 0) return '0s';
                const m = Math.floor(sec / 60);
                const s = Math.floor(sec % 60);
                return m > 0 ? `${m}m ${s}s` : `${s}s`;
            }

            function updateMissionTrack() {
                if (!missionProgressEl || !missionMarkersEl) return;
                missionMarkersEl.innerHTML = '';
                const eff = simState.mission.effectiveDistanceMeters;
                if (eff == null || eff <= 0) {
                    missionProgressEl.style.width = '0%';
                    return;
                }
                const frac = Math.max(0, Math.min(1, simState.mission.distanceCoveredMeters / eff));
                missionProgressEl.style.width = `${(frac*100).toFixed(1)}%`;
                // Markers for planets up to destination
                MISSIONS.filter(m => m.distanceMeters != null)
                    .forEach(m => {
                        const scaled = m.distanceMeters / MISSION_DISTANCE_DIVISOR;
                        if (scaled <= eff) {
                            const pos = Math.max(0, Math.min(1, scaled / eff));
                            const marker = document.createElement('div');
                            marker.className = 'absolute top-0 h-2 w-0.5 bg-white/70';
                            marker.style.left = `calc(${(pos*100).toFixed(2)}% - 1px)`;
                            marker.title = m.name;
                            missionMarkersEl.appendChild(marker);
                        }
                    });
            }

                // Simple landing planet visual at ground when arrived

            function processLanding(dt) {                if (!simState.mission.arrived) return;
                const L = simState.mission.landing;

                // If currently in 'none' state, transition to 'approach' (hold) or 'countdown' based on autoEnabled
                if (L.state === 'none') {
                    if (L.autoEnabled) {
                        L.countdownEndTime = performance.now() + 5000;
                        L.state = 'countdown';
                        setStatus('APPROACH HOLD', 'yellow', true);
                        logMessage('Approach complete. Auto-descent in 5s...');
                    } else {
                        // If auto-land is not enabled, default to 'approach' (hold)
                        L.state = 'approach';
                        setStatus('APPROACH HOLD', 'yellow', true); // Update status for hold
                        logMessage('Approach complete. Holding at destination. Toggle auto-land to descend.');
                    }
                    // Regardless of state change, ensure rocket is stopped for initial approach/hold
                    simState.rocket.vx = 0; simState.rocket.vy = 0; simState.rocket.ay = 0; simState.rocket.ax = 0;
                    simState.rocket.engineShutdown = true;
                    setThrottlePercent(0);
                    return; // Done with initial transition, let next frame handle further steps
                }

                // Handle 'approach' (hold) state when auto-land is disabled
                if (L.state === 'approach') {
                    // Stay in hold, no further action unless auto-land is re-enabled manually
                    simState.rocket.vx = 0; simState.rocket.vy = 0; simState.rocket.ay = 0; simState.rocket.ax = 0;
                    simState.rocket.engineShutdown = true;
                    setThrottlePercent(0);
                    // Check if auto-land was toggled ON while holding
                    if (L.autoEnabled && L.countdownEndTime === 0) { // Only start countdown once
                         L.countdownEndTime = performance.now() + 5000;
                         L.state = 'countdown';
                         setStatus('APPROACH HOLD', 'yellow', true);
                         logMessage('Auto-descent initiated from hold. Commencing in 5s...');
                    }
                    return;
                }
                if (L.state === 'countdown') {
                    if (performance.now() >= L.countdownEndTime) {
                        L.state = 'auto';
                        logMessage('Auto-descent engaged.');
                    } else {
                        return;
                    }
                }
                if (L.state === 'auto' || L.state === 'manual') {
                    // Descent guidance
                    const altitude = simState.rocket.y;
                    let targetVy = -30; // m/s baseline
                    if (altitude < 300) targetVy = -15;
                    if (altitude < 100) targetVy = -8;
                    if (altitude < 20) targetVy = -2;
                    if (altitude <= 0.5) {
                        simState.rocket.y = 0; simState.rocket.vy = 0; simState.rocket.ay = 0;
                        L.state = 'landed';
                        setStatus('LANDED', 'green', false);
                        logMessage('Touchdown confirmed.');
                        simState.running = false;
                        return;
                    }                // AUTO: smoothly reduce throttle to zero and cut engine
                if (L.state === 'auto') {
                    const currentPct = parseInt(throttleSlider.value, 10) || 0;
                    const nextPct = Math.max(0, currentPct - 20 * dt); // reduce ~20%/s
                    setThrottlePercent(nextPct);
                    if (nextPct <= 2) {
                        if (!simState.rocket.engineShutdown) {
                            simState.rocket.engineShutdown = true; // Direct flag set
                            engineShutdownButton.textContent = 'ENGINE ON'; // Update UI
                            logMessage('Auto-land: Engine cutoff.');
                        }
                    }

                    // Apply a gentle controller to achieve targetVy regardless of physics simplifications
                    const dv = targetVy - simState.rocket.vy;
                    const accel = Math.max(-20, Math.min(20, dv));
                    simState.rocket.vy += accel * dt;
                    simState.rocket.y += simState.rocket.vy * dt;
                }
                }
            }

            function updatePhysics(dt) {
                if (!simState.launched) return;

                const activeStages = simState.rocket.stages.filter(s => s.active && !s.separated);
                
                let currentThrust = 0;
                let fuelConsumed = 0;
                let isCurrentStageSpent = true; // Assume spent until proven otherwise

                activeStages.forEach(stage => {
                    if (stage.fuelMass > 0 && !simState.rocket.engineShutdown) {
                        const stageThrust = stage.maxThrust * simState.rocket.throttle;
                        
                        // Thrust is purely vertical without gimbal control
                        currentThrust += stageThrust; // Vertical thrust
                        // No horizontal acceleration from gimbal, simState.rocket.ax remains 0 or from other sources.
                        
                        isCurrentStageSpent = false;
                        
                        // New fuel consumption rate based on a simplified exhaust velocity (Isp proxy).
                        const massFlowRatePerMaxThrust = stage.maxThrust / 5000;
                        const consumed = massFlowRatePerMaxThrust * simState.rocket.throttle * dt; 
                        
                        stage.fuelMass -= consumed;
                        fuelConsumed += consumed;
                        if (stage.fuelMass <= 0) {
                            stage.fuelMass = 0;
                            logMessage(`${stage.name} fuel depleted. Awaiting separation.`);
                        }
                    }
                });

                simState.rocket.totalMass -= fuelConsumed;
                
                // Calculate acceleration
                if (currentThrust === 0) {
                    simState.rocket.ay = -G;
                } else {
                    simState.rocket.ay = currentThrust / simState.rocket.totalMass;
                }
                simState.rocket.vy += simState.rocket.ay * dt;
                simState.rocket.y += simState.rocket.vy * dt;
                simState.rocket.vx += simState.rocket.ax * dt;
                simState.rocket.x += simState.rocket.vx * dt;
                
                // Reset horizontal acceleration for next frame
                simState.rocket.ax = 0;

                // Update mission distance covered (integrate speed)
                const speed = Math.sqrt(simState.rocket.vx*simState.rocket.vx + simState.rocket.vy*simState.rocket.vy);
                simState.mission.distanceCoveredMeters += speed * dt;

                // Arrival detection -> enter approach hold, do not instant land
                const eff = simState.mission.effectiveDistanceMeters;
                if (!simState.mission.arrived && eff != null && simState.mission.distanceCoveredMeters >= eff) {
                    simState.mission.arrived = true;
                    simState.mission.landing.state = 'approach';
                    simState.rocket.engineShutdown = true;
                    simState.rocket.vx = 0; simState.rocket.vy = 0;
                    setStatus('APPROACH HOLD', 'yellow', true);
                    logMessage(`Approach complete at ${simState.mission.name}. Awaiting landing command.`);
                }

                // Process landing sequence if arrived
                if (simState.mission.arrived) {
                    processLanding(dt);
                }

                // Detect complete fuel depletion across all stages once (conditional control loss)
                const remainingFuel = totalRemainingFuelMass();
                if (remainingFuel <= 0 && !simState.mission.lostConnection && !simState.mission.uncontrolled) {
                    const altitude = simState.rocket.y;
                    const inSpace = altitude >= SPACE_ALTITUDE;
                    simState.rocket.engineShutdown = true;
                    // Disable interactive controls either way
                    throttleSlider.disabled = true;
                    stageButton.disabled = true;
                    engineShutdownButton.disabled = true;
                    abortButton.disabled = true;
                    generateReportButton.disabled = false; // allow report
                    if (inSpace) {
                        simState.mission.lostConnection = true;
                        simState.running = false; // stop sim loop, report available
                        logMessage('Fuel depleted in space. Connection lost.');
                        setStatus('LOST LINK', 'red', false);
                    } else {
                        simState.mission.uncontrolled = true;
                        // Keep simulation running to fall ballistically
                        logMessage('Fuel depleted in atmosphere. Uncontrolled descent initiated.');
                        setStatus('UNCONTROLLED', 'yellow', true);
                    }
                }

                // Ground collision detection
                if (simState.rocket.y < 0) {
                    simState.rocket.y = 0;
                    simState.rocket.vy = 0;
                    simState.rocket.ay = 0;
                    simState.running = false;
                    setStatus('CRASHED', 'red', false);
                    logMessage('Mission Failure: Vehicle has crashed.');
                    simState.crash.crashed = true;
                    simState.crash.explosionTime = performance.now();
                    createExplosionParticles();
                }

                // New: Check if simulation has ended (crash, abort, or soft landing)
                if (!simState.running && simState.launched) {
                    generateReportButton.disabled = false;
                }
                
                // Max Altitude Tracking
                if (simState.rocket.y > simState.stats.maxAltitude) {
                    simState.stats.maxAltitude = simState.rocket.y;
                }

                // Apogee Calculation (only when thrust is zero and velocity is positive)
                if (currentThrust === 0 && simState.rocket.vy > 0) {
                    const timeToApogee = simState.rocket.vy / G;
                    simState.stats.apogee = simState.rocket.y + (simState.rocket.vy * timeToApogee) - (0.5 * G * timeToApogee * timeToApogee);
                } else {
                    simState.stats.apogee = 0;
                }
                
                // AUTOMATIC STAGING check
                const nextStageIndex = simState.rocket.currentStage + 1;
                const canAutoStage = nextStageIndex < simState.rocket.stages.length && isCurrentStageSpent;
                if (canAutoStage) {
                    handleStageSeparation(true); // Auto stage when fuel depleted
                }

                // Data logging for graphs
                const elapsed = (performance.now() - simState.startTime) / 1000;
                if (elapsed - simState.lastDataLogTime > 0.5) {
                    simState.flightData.time.push(elapsed.toFixed(1));
                    simState.flightData.altitude.push(simState.rocket.y);
                    simState.flightData.velocity.push(simState.rocket.vy);
                    simState.flightData.positions.push({x: simState.rocket.x, y: simState.rocket.y});
                    simState.lastDataLogTime = elapsed;
                    updateGraphs();
                }
            }
            
            function updateGraphs() {
                altitudeChart.data.labels = simState.flightData.time;
                altitudeChart.data.datasets[0].data = simState.flightData.altitude;
                altitudeChart.update();
                
                velocityChart.data.labels = simState.flightData.time;
                velocityChart.data.datasets[0].data = simState.flightData.velocity;
                velocityChart.update();
            }

            function calculateTotalMass() {
                simState.rocket.totalMass = simState.rocket.stages
                    .filter(s => !s.separated)
                    .reduce((sum, stage) => sum + stage.dryMass + stage.fuelMass, 0);
            }

            // --- Drawing (Unchanged) ---
            function draw() {
                ctx.save();
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Camera follows the rocket's altitude but keeps rocket centered
                simState.camera.y = simState.rocket.y * PIXELS_PER_METER;
                const canvasWidth = canvas.offsetWidth || canvas.width;
                const canvasHeight = canvas.offsetHeight || canvas.height;
                
                // Keep rocket in center of screen and apply zoom
                ctx.translate(canvasWidth / 2, canvasHeight / 2);
                ctx.scale(simState.camera.zoom, simState.camera.zoom);
                
                // Apply rocket position offset for horizontal movement
                ctx.translate(-simState.rocket.x * PIXELS_PER_METER, 0);

                drawBackground();
                drawEnvironmentalEffects();
                drawLaunchpad();
                drawAltitudeMarkers();
                
                if (simState.crash.crashed) {
                    drawExplosion();
                } else {
                    drawFlightPath();
                    drawVelocityVector();
                    drawRocket();
                    if (simState.launched && simState.rocket.throttle > 0) {
                        const activeStages = simState.rocket.stages.filter(s => s.active && s.fuelMass > 0);
                        if (activeStages.length > 0) {
                            drawFlame();
                        }
                    }
                }
                
                ctx.restore();
                drawStarfield(simState.rocket.y);
            }

            function createExplosionParticles() {
                const particleCount = 100;
                for (let i = 0; i < particleCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 80 + 20;
                    simState.crash.particles.push({
                        x: 0,
                        y: 0,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 1, // 1 = 100% life
                        color: ['#ffa500', '#ff4500', '#ff6347', '#d3d3d3', '#a9a9a9'][Math.floor(Math.random() * 5)]
                    });
                }
            }
            
            function drawExplosion() {
                const explosionDuration = 2000; // 2 seconds
                const dt = (performance.now() - simState.lastFrameTime) / 1000;
                
                // Remove dead particles
                simState.crash.particles = simState.crash.particles.filter(p => p.life > 0);
                
                simState.crash.particles.forEach(p => {
                    p.x += p.vx * dt;
                    p.y += p.vy * dt;
                    p.vy += G * 5 * dt; // Gravity on particles (exaggerated for effect)
                    p.life -= dt / 2; // Particle life decreases over 2 seconds
                    
                    if (p.life > 0) {
                        ctx.fillStyle = `${p.color}${Math.floor(p.life * 255).toString(16).padStart(2, '0')}`;
                        ctx.beginPath();
                        ctx.arc(p.x, -p.y, 2 + p.life * 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
            }


            function drawBackground() {
                const canvasWidth = canvas.offsetWidth || canvas.width;
                const canvasHeight = canvas.offsetHeight || canvas.height;

                // If we've arrived at a destination, render a themed planetary sky
                if (simState.mission.arrived && simState.mission.name) {
                    drawPlanetSky(simState.mission.name, canvasWidth, canvasHeight);
                    return;
                }

                const skyColor = getSkyColor(simState.rocket.y);
                ctx.fillStyle = skyColor;
                // Fill entire background
                ctx.fillRect(-canvasWidth/2, -canvasHeight/2, canvasWidth, canvasHeight);
            }

            function drawPlanetSky(name, canvasWidth, canvasHeight) {
                const n = (name || '').toLowerCase();
                let top = '#00111a', mid = '#002233', bot = '#00334d';
                if (n.includes('mercury')) { top = '#3c3c3c'; mid = '#5a524a'; bot = '#4a4139'; }
                else if (n.includes('venus')) { top = '#e9d7a9'; mid = '#d9c27a'; bot = '#caa95a'; }
                else if (n.includes('mars')) { top = '#6b2d1a'; mid = '#8c3f24'; bot = '#a14a2a'; }
                else if (n.includes('jupiter')) { top = '#b07d52'; mid = '#c89262'; bot = '#a87149'; }
                else if (n.includes('saturn')) { top = '#d4c192'; mid = '#c8b37e'; bot = '#b8a169'; }
                else if (n.includes('uranus')) { top = '#9be7e8'; mid = '#7ed4d6'; bot = '#5fc2c5'; }
                else if (n.includes('neptune')) { top = '#1a3d8f'; mid = '#1f4fb2'; bot = '#2466d1'; }

                // Gradient sky
                const grad = ctx.createLinearGradient(0, -canvasHeight/2, 0, canvasHeight/2);
                grad.addColorStop(0, top);
                grad.addColorStop(0.5, mid);
                grad.addColorStop(1, bot);
                ctx.fillStyle = grad;
                ctx.fillRect(-canvasWidth/2, -canvasHeight/2, canvasWidth, canvasHeight);

                // Add subtle bands for gas giants
                if (n.includes('jupiter') || n.includes('saturn')) {
                    ctx.save();
                    ctx.globalAlpha = 0.2;
                    const bands = n.includes('jupiter') ? 12 : 8;
                    for (let i = 0; i < bands; i++) {
                        const y = -canvasHeight/2 + (i + 1) * (canvasHeight / (bands + 1));
                        ctx.fillStyle = i % 2 === 0 ? '#ffffff' : '#000000';
                        ctx.fillRect(-canvasWidth/2, y, canvasWidth, 6);
                    }
                    // Saturn ring hint
                    if (n.includes('saturn')) {
                        ctx.globalAlpha = 0.15;
                        ctx.fillStyle = '#ffffff';
                        ctx.rotate(-0.15);
                        ctx.fillRect(-canvasWidth/2, -10, canvasWidth, 20);
                    }
                    ctx.restore();
                }

                // Sparse stars
                ctx.save();
                ctx.globalAlpha = 0.6;
                ctx.fillStyle = '#ffffff';
                for (let i = 0; i < 120; i++) {
                    const x = (Math.sin(i * 12.9898) * 43758.5453) % canvasWidth;
                    const y = (Math.cos(i * 78.233) * 12345.6789) % canvasHeight;
                    const sx = -canvasWidth/2 + (x + canvasWidth) % canvasWidth;
                    const sy = -canvasHeight/2 + (y + canvasHeight) % canvasHeight;
                    const size = (Math.abs(Math.sin(i)) % 2) * 1.5;
                    ctx.fillRect(sx, sy, size, size);
                }
                ctx.restore();
            }
            
            function drawEnvironmentalEffects() {
                const altitude = simState.rocket.y;
                const canvasWidth = canvas.offsetWidth || canvas.width;
                const canvasHeight = canvas.offsetHeight || canvas.height;
                
                // Cloud layers (5km to 15km)
                if (altitude > 3000 && altitude < 20000) {
                    ctx.save();
                    const cloudOpacity = Math.sin((altitude - 3000) / 2000) * 0.3;
                    if (cloudOpacity > 0) {
                        ctx.fillStyle = `rgba(255, 255, 255, ${cloudOpacity})`;
                        for (let i = 0; i < 20; i++) {
                            const x = (Math.sin(i * 2.34 + altitude * 0.0001) * canvasWidth * 0.8);
                            const y = (Math.cos(i * 1.78 + altitude * 0.0001) * 50) - simState.camera.y + (i * 40);
                            const size = 30 + Math.sin(i * 3.45) * 20;
                            ctx.beginPath();
                            ctx.arc(x, y, size, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                    ctx.restore();
                }
                
                // Atmosphere density visualization
                if (altitude < 100000) {
                    const density = Math.max(0, 1 - altitude / 100000);
                    const atmosphereColor = `rgba(135, 206, 250, ${density * 0.1})`;
                    ctx.fillStyle = atmosphereColor;
                    ctx.fillRect(-canvasWidth/2, -canvasHeight/2, canvasWidth, canvasHeight);
                }
            }
            
            function drawAltitudeMarkers() {
                const canvasWidth = canvas.offsetWidth || canvas.width;
                const altitude = simState.rocket.y;
                
                // Draw altitude markers on the right side
                ctx.save();
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.font = '12px Orbitron';
                ctx.textAlign = 'left';
                
                // Major altitude markers every 10km
                for (let alt = 0; alt <= 200000; alt += 10000) {
                    const y = (alt - altitude) * PIXELS_PER_METER;
                    if (Math.abs(y) < canvas.height) {
                        ctx.fillRect(canvasWidth/2 - 60, y - 1, 40, 2);
                        ctx.fillText(`${alt/1000}km`, canvasWidth/2 - 55, y + 4);
                    }
                }
                
                // Minor markers every 1km
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                for (let alt = 0; alt <= 200000; alt += 1000) {
                    if (alt % 10000 !== 0) {
                        const y = (alt - altitude) * PIXELS_PER_METER;
                        if (Math.abs(y) < canvas.height) {
                            ctx.fillRect(canvasWidth/2 - 50, y, 20, 1);
                        }
                    }
                }
                ctx.restore();
            }

            function drawStarfield(altitude) {
                const transitionStart = 50000;
                const transitionEnd = 100000;
                let opacity = 0;

                if (altitude > transitionStart) {
                    opacity = Math.min(1, (altitude - transitionStart) / (transitionEnd - transitionStart));
                }

                if (opacity > 0) {
                    ctx.save();
                    ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                    const starCount = 200;
                    const canvasWidth = canvas.offsetWidth || canvas.width;
                    const canvasHeight = canvas.offsetHeight || canvas.height;
                    for (let i = 0; i < starCount; i++) {
                        // These calculations use fixed screen coordinates to keep the stars still
                        const x = (Math.sin(i * 1.23) * canvasWidth/2 * 1.5 + canvasWidth/2);
                        const y = (Math.cos(i * 3.45) * canvasHeight * 1.5) % canvasHeight;
                        const size = Math.pow(Math.sin(i * 5.67), 4) * 2;
                        ctx.fillRect(x, y, size, size);
                    }
                    ctx.restore();
                }
            }


            function getSkyColor(altitude) {
                // Color transition from blue sky to black space
                const maxAlt = 100000;
                const t = Math.min(1, altitude / maxAlt);
                const r = Math.floor(66 * (1 - t));
                const g = Math.floor(134 * (1 - t));
                const b = Math.floor(244 * (1 - t));
                return `rgb(${r},${g},${b})`;
            }

            function drawLaunchpad() {
                const canvasWidth = canvas.offsetWidth || canvas.width;
                const canvasHeight = canvas.offsetHeight || canvas.height;
                const groundY = canvasHeight * 0.8; // Fixed ground position
                const towerHeight = 150;
                const towerWidth = 30;
                
                // Only draw ground and tower if we're close to ground level
                const groundVisibilityRange = 2000; // meters
                if (simState.rocket.y < groundVisibilityRange) {
                    // Ground (sand/concrete thing) - fixed position
                    ctx.fillStyle = '#6b4226';
                    ctx.fillRect(-canvasWidth / 2, groundY - canvasHeight * 0.8 + simState.camera.y, canvasWidth, 1000);
                    
                    // Launch tower - fixed position relative to ground
                    ctx.fillStyle = '#808080';
                    const towerY = groundY - canvasHeight * 0.8 + simState.camera.y;
                    ctx.fillRect(-towerWidth / 2 - 50, towerY - towerHeight, towerWidth, towerHeight);
                    ctx.fillStyle = '#606060';
                    for (let i = 0; i < 8; i++) {
                        ctx.fillRect(-towerWidth/2 - 50, towerY - towerHeight + i * 20, towerWidth, 5);
                    }
                }
            }
            
            function drawRocket() {
                const rocketX = -simState.rocket.width / 2;
                // Rocket is drawn relative to the translated origin (0, 0)
                const baseOfRocketY = 0; 
                
                ctx.save();
                ctx.translate(0, baseOfRocketY);

                // Debug: Draw a visible outline around the rocket area
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(rocketX - 5, -simState.rocket.height - 5, simState.rocket.width + 10, simState.rocket.height + 10);
                ctx.setLineDash([]);

                let currentY = 0; // Tracks the current drawing position (from bottom up)

                // Draw stages from bottom (index 0) to top
                for (let i = 0; i < simState.rocket.stages.length; i++) {
                    const stage = simState.rocket.stages[i];
                    if (!stage.separated) {
                        const stageHeight = stage.visualHeight;
                        const stageBottomY = currentY - stageHeight; // Y is negative (up)
                        
                        // Draw Stage Body with brighter colors for visibility
                        ctx.fillStyle = '#ffffff';
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.rect(rocketX, stageBottomY, simState.rocket.width, stageHeight);
                        ctx.fill();
                        ctx.stroke();
                        
                        // Stage Label
                        ctx.fillStyle = '#000';
                        ctx.font = 'bold 12px Orbitron';
                        ctx.textAlign = 'center';
                        ctx.fillText(stage.name, 0, stageBottomY + stageHeight / 2 + 4);
                        
                        currentY = stageBottomY;
                    }
                }
                
                // Draw Nose Cone on top of the last remaining stage
                const noseY = currentY;
                ctx.fillStyle = '#ff0000';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(rocketX, noseY);
                ctx.lineTo(rocketX + simState.rocket.width, noseY);
                ctx.lineTo(rocketX + simState.rocket.width/2, noseY - NOSE_HEIGHT);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                ctx.restore();
            }
            
            function drawFlightPath() {
                if (simState.flightData.positions.length < 2) return;
                
                ctx.save();
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.6)';
                ctx.lineWidth = 2;
                ctx.setLineDash([]);
                
                ctx.beginPath();
                const positions = simState.flightData.positions;
                const firstPos = positions[0];
                ctx.moveTo((firstPos.x - simState.rocket.x) * PIXELS_PER_METER, 
                          (firstPos.y - simState.rocket.y) * PIXELS_PER_METER);
                
                for (let i = 1; i < positions.length; i++) {
                    const pos = positions[i];
                    ctx.lineTo((pos.x - simState.rocket.x) * PIXELS_PER_METER, 
                              (pos.y - simState.rocket.y) * PIXELS_PER_METER);
                }
                
                ctx.stroke();
                ctx.restore();
            }
            
            function drawVelocityVector() {
                if (!simState.launched) return;
                
                const velocityScale = 0.1; // Scale factor for velocity vector display
                const vxPixels = simState.rocket.vx * velocityScale;
                const vyPixels = -simState.rocket.vy * velocityScale; // Negative because canvas Y is inverted
                
                if (Math.abs(vxPixels) < 1 && Math.abs(vyPixels) < 1) return;
                
                ctx.save();
                ctx.strokeStyle = '#ffff00';
                ctx.fillStyle = '#ffff00';
                ctx.lineWidth = 3;
                
                // Draw velocity vector line
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(vxPixels, vyPixels);
                ctx.stroke();
                
                // Draw arrowhead
                const arrowLength = 10;
                const angle = Math.atan2(vyPixels, vxPixels);
                
                ctx.beginPath();
                ctx.moveTo(vxPixels, vyPixels);
                ctx.lineTo(vxPixels - arrowLength * Math.cos(angle - Math.PI/6), 
                          vyPixels - arrowLength * Math.sin(angle - Math.PI/6));
                ctx.lineTo(vxPixels - arrowLength * Math.cos(angle + Math.PI/6), 
                          vyPixels - arrowLength * Math.sin(angle + Math.PI/6));
                ctx.closePath();
                ctx.fill();
                
                // Display velocity magnitude
                const totalVel = Math.sqrt(simState.rocket.vx**2 + simState.rocket.vy**2);
                ctx.fillStyle = 'rgba(255, 255, 0, 0.8)';
                ctx.font = '12px Orbitron';
                ctx.textAlign = 'left';
                ctx.fillText(`${totalVel.toFixed(1)} m/s`, vxPixels + 15, vyPixels + 5);
                
                ctx.restore();
            }

            function drawFlame() {
                const rocketX = -simState.rocket.width / 2;
                // Flame starts at the bottom of the current rocket body (baseOfRocketY = 0 after translate)
                const baseOfRocket = 0; 
                
                const flameLength = (50 + Math.random() * 10) * simState.rocket.throttle;
                
                ctx.save();
                ctx.translate(0, baseOfRocket);
                
                // Inner Yellow Flame
                ctx.fillStyle = 'rgba(255, 255, 0, 0.9)';
                ctx.beginPath();
                ctx.moveTo(rocketX + simState.rocket.width / 2 - 4, 0);
                ctx.lineTo(rocketX + simState.rocket.width / 2 + 4, 0);
                ctx.lineTo(rocketX + simState.rocket.width / 2, flameLength * 0.7);
                ctx.closePath();
                ctx.fill();

                // Outer Orange Flame
                ctx.fillStyle = 'rgba(255, 165, 0, 0.8)';
                ctx.beginPath();
                ctx.moveTo(rocketX, 0);
                ctx.lineTo(rocketX + simState.rocket.width, 0);
                ctx.lineTo(rocketX + simState.rocket.width / 2, flameLength);
                ctx.closePath();
                ctx.fill();
                
                ctx.restore();
            }

            function km(valMeters) { return (valMeters/1000); }            function updateLandingOverlay() {
                const overlay = document.getElementById('landing-overlay');
                if (!overlay) return;
                const arrived = simState.mission.arrived;
                if (!arrived) { overlay.classList.add('hidden'); return; }
                overlay.classList.remove('hidden');
                const L = simState.mission.landing;
                const tPct = Math.round((simState.rocket.throttle || 0) * 100);
                const vy = simState.rocket.vy;
                const countdownLeft = L.state === 'countdown' ? Math.max(0, Math.ceil((L.countdownEndTime - performance.now())/1000)) : 0;
                
                if (L.state === 'approach') {
                    overlay.innerHTML = `
                        <div class="font-orbitron text-yellow-300 mb-1">HOLDING AT DESTINATION</div>
                        <p class="text-xs text-gray-300 mb-1">Auto land is disabled. Activate it using the checkbox to begin descent.</p>
                        <ul class="space-y-1 mt-2">
                            <li>Throttle: ${tPct}%</li>
                            <li>Vertical Speed: ${vy.toFixed(1)} m/s</li>
                        </ul>
                    `;
                } else { // countdown, auto, landed
                    overlay.innerHTML = `
                        <div class="font-orbitron text-green-300 mb-1">AUTO LANDING</div>
                        ${L.state === 'countdown' ? `<div class="text-xs text-gray-300 mb-1">Auto-descent in T-${countdownLeft}s</div>` : ''}
                        <ul class="space-y-1">
                            <li>Throttle: ${tPct}%</li>
                            <li>Vertical Speed: ${vy.toFixed(1)} m/s</li>
                            <li>Status: ${L.state === 'landed' ? 'Touchdown confirmed' : 'Controlled descent'}</li>
                        </ul>
                    `;
                }
            }

            function updateUI() {
                const fmt = (val, unit, dec = 0) => val.toFixed(dec).replace(/\B(?=(\d{3})+(?!\d))/g, ",") + unit;
                const lost = simState.mission.lostConnection;
                altitudeValue.textContent = lost ? 'LOST LINK' : fmt(simState.rocket.y, ' m');
                velocity.textContent = lost ? 'LOST LINK' : fmt(simState.rocket.vy, ' m/s');
                maxAltitude.textContent = lost ? 'LOST LINK' : fmt(simState.stats.maxAltitude, ' m');
                
                const activeStages = simState.rocket.stages.filter(s => s.active);
                const currentThrust = activeStages.reduce((sum, stage) => {
                    // Only produce thrust if fuel is present
                    return sum + (stage.fuelMass > 0 ? stage.maxThrust * simState.rocket.throttle : 0);
                }, 0);
                
                thrust.textContent = lost ? 'LOST LINK' : fmt(currentThrust / 1000, ' kN');
                const currentTWR = simState.rocket.totalMass > 0 ? currentThrust / (simState.rocket.totalMass * G) : 0;
                twr.textContent = lost ? 'LOST LINK' : currentTWR.toFixed(2);
                totalMass.textContent = lost ? 'LOST LINK' : fmt(simState.rocket.totalMass, ' kg');
                apogee.textContent = lost ? 'LOST LINK' : (simState.stats.apogee > 0 ? fmt(simState.stats.apogee, ' m') : 'N/A');

                // Mission UI updates
                missionNameEl.textContent = simState.mission.name;
                const eff = simState.mission.effectiveDistanceMeters;
                if (eff == null) {
                    missionDistanceEl.textContent = 'N/A';
                    missionCoveredEl.textContent = `${km(simState.mission.distanceCoveredMeters).toFixed(0)} km`;
                    missionRemainingEl.textContent = 'N/A';
                    missionBurnTimeEl.textContent = formatSeconds(remainingBurnTimeSec(simState.rocket.throttle));
                    missionFuelSpentEl.textContent = `${Math.round((simState.rocket.totalFuelCapacity - totalRemainingFuelMass())).toLocaleString()} kg`;
                    if (simState.mission.uncontrolled) {
                        missionStatusEl.textContent = 'Uncontrolled descent';
                        missionStatusEl.className = 'font-orbitron text-yellow-400';
                    } else {
                        missionStatusEl.textContent = 'Free flight';
                        missionStatusEl.className = 'font-orbitron text-yellow-400';
                    }
                    updateMissionTrack();
                } else {
                    const dist = eff;
                    const rawCovered = simState.mission.distanceCoveredMeters;
                    const covered = Math.min(rawCovered, dist);
                    const remaining = Math.max(0, dist - covered);
                    missionDistanceEl.textContent = `${km(dist).toFixed(0)} km`;
                    missionCoveredEl.textContent = `${km(covered).toFixed(0)} km`;
                    missionRemainingEl.textContent = `${km(remaining).toFixed(0)} km`;
                    const burnLeft = remainingBurnTimeSec(simState.rocket.throttle);
                    missionBurnTimeEl.textContent = formatSeconds(burnLeft);
                    missionFuelSpentEl.textContent = `${Math.round((simState.rocket.totalFuelCapacity - totalRemainingFuelMass())).toLocaleString()} kg`;
                    updateMissionTrack();

                    if (simState.mission.lostConnection) {
                        missionStatusEl.textContent = 'Lost link';
                        missionStatusEl.className = 'font-orbitron text-red-400';
                    } else if (simState.mission.uncontrolled) {
                        missionStatusEl.textContent = 'Uncontrolled descent';
                        missionStatusEl.className = 'font-orbitron text-yellow-400';
                    } else if (simState.mission.arrived) {
                        const s = simState.mission.landing.state;
                        const map = { approach: 'Approach hold', countdown: 'Auto-descent in 5s', auto: 'Auto-descent', manual: 'Manual descent', landed: 'Landed' };
                        missionStatusEl.textContent = map[s] || 'Approach';
                        missionStatusEl.className = s === 'landed' ? 'font-orbitron text-green-400' : 'font-orbitron text-yellow-400';
                    } else {
                        const speed = Math.sqrt(simState.rocket.vx*simState.rocket.vx + simState.rocket.vy*simState.rocket.vy);
                        const potential = speed * burnLeft;
                        if (potential >= remaining) {
                            missionStatusEl.textContent = 'Likely to succeed';
                            missionStatusEl.className = 'font-orbitron text-green-400';
                        } else {
                            missionStatusEl.textContent = 'Likely to fail';
                            missionStatusEl.className = 'font-orbitron text-red-400';
                        }
                    }
                }

                if (simState.running) {
                    const elapsed = (performance.now() - simState.startTime) / 1000;
                    const h = Math.floor(elapsed / 3600).toString().padStart(2, '0');
                    const m = Math.floor((elapsed % 3600) / 60).toString().padStart(2, '0');
                    const s = Math.floor(elapsed % 60).toString().padStart(2, '0');
                    timeElapsed.textContent = `${h}:${m}:${s}`;
                } else if (!simState.launched) {
                    timeElapsed.textContent = "00:00:00";
                }
                
                // Update report button note visibility
                if (simState.launched && !simState.running) {
                    reportNote.classList.remove('hidden');
                } else {
                    reportNote.classList.add('hidden');
                }

                // Landing controls enable/disable
                const arrived = simState.mission.arrived;
                const L = simState.mission.landing || { state: 'none' };
                const disableLanding = simState.mission.lostConnection || !arrived || L.state === 'landed';                // Landing controls enable/disable
                if (autoLandCheckbox) autoLandCheckbox.disabled = simState.mission.lostConnection || simState.mission.uncontrolled;

                updateLandingOverlay();
                updateStagingUI();
            }
            
            function updateStagingUI() {
                stagingContainer.innerHTML = '';

                // Summary: Max Fuel to Burn (total capacity)
                const maxFuelBurn = (simState.rocket.totalFuelCapacity != null)
                    ? simState.rocket.totalFuelCapacity
                    : simState.rocket.stages.reduce((sum, s) => sum + (s.fuelCapacity ?? s.initialFuelMass ?? 0), 0);
                const summary = document.createElement('div');
                summary.className = 'p-2 mb-2 bg-gray-800 rounded border border-gray-700 text-sm';
                const fuelSpent = Math.max(0, Math.round(simState.rocket.totalFuelCapacity - totalRemainingFuelMass()));
                summary.innerHTML = `
                    <div class="flex justify-between"><span class="text-gray-400">Max Fuel to Burn</span><span class="font-orbitron text-white">${Math.round(maxFuelBurn).toLocaleString()} kg</span></div>
                    <div class="flex justify-between"><span class="text-gray-400">Fuel Spent</span><span class="font-orbitron text-white">${fuelSpent.toLocaleString()} kg</span></div>
                `;
                stagingContainer.appendChild(summary);

                simState.rocket.stages.slice().reverse().forEach((stage, index) => {
                    const reversedIndex = simState.rocket.stages.length - 1 - index;
                    const capacity = stage.fuelCapacity ?? stage.initialFuelMass ?? 0;
                    const fuelPercentage = capacity > 0 ? (stage.fuelMass / capacity) * 100 : 0;
                    
                    const container = document.createElement('div');
                    container.className = `p-2 rounded mb-2 border-2 ${reversedIndex === simState.rocket.currentStage && !stage.separated ? 'border-cyan-400' : 'border-gray-600'} ${stage.separated ? 'opacity-40' : ''}`;
                    
                    let statusHtml;
                    if (stage.separated) {
                         statusHtml = `<span class=\"text-gray-500 font-bold\">JETTISONED</span>`;
                    } else if (stage.active && stage.fuelMass > 0) {
                         statusHtml = `<span class=\"text-green-400 font-bold\">ACTIVE</span>`;
                    } else if (stage.active && stage.fuelMass <= 0) {
                        statusHtml = `<span class=\"text-red-400 font-bold\">DEPLETED</span>`;
                    } else {
                         statusHtml = `<span class=\"text-yellow-500 font-bold\">AWAITING</span>`;
                    }

                    const fuelText = `${Math.max(0, Math.round(stage.fuelMass)).toLocaleString()} / ${Math.round(capacity).toLocaleString()} kg`;

                    container.innerHTML = `
                        <div class=\"flex justify-between items-center text-sm font-bold\">
                            <span>STAGE ${reversedIndex + 1}: ${stage.name}</span>
                            ${statusHtml}
                        </div>
                        <div class=\"w-full bg-gray-700 rounded-full h-2.5 mt-1\">
                            <div class=\"bg-green-500 h-2.5 rounded-full\" style=\"width: ${fuelPercentage}%\"></div>
                        </div>
                        <div class=\"mt-1 text-xs text-gray-300 text-right\">${fuelText}</div>
                    `;
                    stagingContainer.appendChild(container);
                });
            }

    
            function renderMissionTargets() {
                if (!missionListContainer) return;
                missionListContainer.innerHTML = '';
                MISSIONS.forEach(m => {
                    const card = document.createElement('div');
                    const isSelected = selectedMissionTarget && selectedMissionTarget.id === m.id;
                    card.className = `p-3 rounded-lg border-2 cursor-pointer transition-all ${isSelected ? 'border-cyan-400' : 'border-gray-700 hover:border-cyan-400'} bg-gray-900`;
                    const distText = m.distanceMeters == null ? 'N/A' : `${Math.round((m.distanceMeters / MISSION_DISTANCE_DIVISOR) / 1000).toLocaleString()} km (scaled)`;
                    card.innerHTML = `
                        <div class="flex justify-between items-center">
                            <div>
                                <div class="text-lg font-bold text-white">${m.name}</div>
                                <div class="text-xs text-gray-400">Distance: ${distText}</div>
                            </div>
                            <div class="text-cyan-400 font-orbitron">SELECT</div>
                        </div>
                    `;
                    card.addEventListener('click', () => {
                        selectedMissionTarget = m;
                        renderMissionTargets();
                    });
                    missionListContainer.appendChild(card);
                });
            }

            function renderHangarDashboard() {
                rocketListContainer.innerHTML = ''; 
                
                ROCKET_BLUEPRINTS.forEach(blueprint => {
                    const card = document.createElement('div');
                    card.className = "bg-gray-900 p-4 rounded-lg border-2 border-gray-700 hover:border-cyan-400 transition-all duration-300 cursor-pointer";
                    card.innerHTML = `
                        <h3 class="text-xl font-bold font-orbitron text-green-400 mb-2">${blueprint.name}</h3>
                        <p class="text-sm text-gray-400 mb-3">${blueprint.description}</p>
                        <ul class="text-sm space-y-1">
                            <li class="flex justify-between"><span>Payload Mass:</span> <span class="font-orbitron text-white">${blueprint.payloadMass} kg</span></li>
                            <li class="flex justify-between"><span>Total Stages:</span> <span class="font-orbitron text-white">${blueprint.stages.length}</span></li>
                        </ul>
                        <button data-rocket-id="${blueprint.id}" class="select-rocket-btn mt-4 w-full p-2 bg-blue-600 hover:bg-blue-500 rounded font-bold transition-all">SELECT VEHICLE</button>
                    `;
                    rocketListContainer.appendChild(card);
                });
                
                
                document.querySelectorAll('.select-rocket-btn').forEach(button => {
                    button.addEventListener('click', (e) => {
                        const rocketId = e.target.getAttribute('data-rocket-id');
                        selectRocket(rocketId);
                    });
                });
            }

            // Initial render of mission targets as well
            renderMissionTargets();

            function selectRocket(rocketId) {
                selectedRocketBlueprint = ROCKET_BLUEPRINTS.find(r => r.id === rocketId);
                if (selectedRocketBlueprint) {
                    if (!selectedMissionTarget) selectedMissionTarget = MISSIONS[0];
                    hangarDashboard.classList.add('hidden'); 
                    init(); 
                } else {
                    
                    logMessage('Error: Rocket blueprint not found. ðŸš¨'); 
                }
            }


            function setStatus(text, color, pulse) {
                statusText.textContent = text;
                statusText.className = `font-bold font-orbitron text-${color}-500`;
                statusLight.className = `w-4 h-4 rounded-full bg-${color}-500 inline-block mr-2 ${pulse ? 'animate-pulse' : ''}`;
            }

            function logMessage(text) {
                const timestamp = new Date().toLocaleTimeString();
                simState.messages.push(`[${timestamp}] ${text}`);
                if (simState.messages.length > 5) {
                    simState.messages.shift();
                }
                messageDisplay.textContent = simState.messages[simState.messages.length - 1];
                messageDisplay.classList.remove('animate-ping');
                void messageDisplay.offsetWidth;
                messageDisplay.classList.add('animate-ping');
                setTimeout(() => messageDisplay.classList.remove('animate-ping'), 500);
            }

            // Populate hangar UI on load
            renderHangarDashboard();

            function handleIgnition() {
                if (simState.launched) return;
                simState.running = true;
                simState.launched = true;
                simState.startTime = performance.now();
                simState.lastDataLogTime = 0;
                simState.rocket.stages[0].active = true;
                simState.rocket.currentStage = 0;
                setStatus('LIFTOFF', 'green', true);
                logMessage('Main engine ignition and liftoff!');
                ignitionButton.disabled = true;
                stageButton.disabled = false; // Enable staging button after launch
                engineShutdownButton.disabled = false;
                abortButton.disabled = false;
                generateReportButton.disabled = true; // Disable report until end of flight
            }

            // isAutomatic flag determines if this was called by fuel depletion
            function handleStageSeparation(isAutomatic = false) {
                const currentStageIndex = simState.rocket.currentStage;
                const currentStage = simState.rocket.stages[currentStageIndex];
                
                if (currentStageIndex + 1 >= simState.rocket.stages.length) {
                    logMessage('No more stages to separate.');
                    stageButton.disabled = true;
                    return;
                }

                if (!isAutomatic && currentStage.fuelMass > 0) {
                    // Manual override separation
                    logMessage(`WARNING: Stage ${currentStageIndex + 1} manually separated with remaining fuel!`);
                } else if (!isAutomatic && currentStage.fuelMass <= 0) {
                    logMessage(`Stage ${currentStageIndex + 1} separation confirmed.`);
                }
                
                // Jettison current active stage
                currentStage.active = false;
                currentStage.separated = true;
                
                // Activate next stage
                simState.rocket.currentStage++;
                simState.rocket.stages[simState.rocket.currentStage].active = true;
                
                // Recalculate physical mass and visual mass
                calculateTotalMass();
                updateRocketVisualHeight(); 
                
                logMessage(`Stage ${currentStageIndex + 1} separated. Stage ${simState.rocket.currentStage + 1} ignition.`);
            }

            function setThrottlePercent(percent) {
                const p = Math.max(0, Math.min(100, Math.round(percent)));
                throttleSlider.value = p;
                throttleSlider.dispatchEvent(new Event('input'));
            }

            function handleThrottleChange(e) {
                const value = parseInt(e.target.value, 10);
                simState.rocket.throttle = value / 100;
                throttleValue.textContent = value;
            }
            

            
            function handleTimeScaleChange(e) {
                const value = parseFloat(e.target.value);
                simState.simulation.timeScale = value;
                timeScaleValue.textContent = value.toFixed(1);
            }
            
            function handleZoomChange(e) {
                const value = parseFloat(e.target.value);
                simState.camera.zoom = value;
                zoomValue.textContent = value.toFixed(1);
            }
            
            function handleEngineShutdown() {
                if (!simState.launched) return;
                simState.rocket.engineShutdown = !simState.rocket.engineShutdown;
                const status = simState.rocket.engineShutdown ? 'SHUTDOWN' : 'RESTART';
                engineShutdownButton.textContent = simState.rocket.engineShutdown ? 'ENGINE ON' : 'ENGINE CUT';
                logMessage(`Engine ${status}`);
            }
            
            function handleAbort() {
                if (!simState.launched || simState.simulation.aborted) return;
                simState.simulation.aborted = true;
                simState.rocket.engineShutdown = true;
                simState.running = false; // stop physics updates
                setStatus('ABORTED', 'red', false);
                logMessage('Mission aborted by user! Initiating mid-air destruct.');

                // Mid-air explosion visual
                simState.crash.crashed = true;
                simState.crash.explosionTime = performance.now();
                createExplosionParticles();

                // Disable interactive controls on abort
                throttleSlider.disabled = true;
                stageButton.disabled = true;
                engineShutdownButton.disabled = true;
                abortButton.disabled = true;

                generateReportButton.disabled = false; // Enable report generation
            }
            
            function handlePause() {
                simState.simulation.paused = !simState.simulation.paused;
                pauseButton.textContent = simState.simulation.paused ? 'RESUME' : 'PAUSE';
                const status = simState.simulation.paused ? 'PAUSED' : 'RUNNING';
                logMessage(`Simulation ${status}`);
            }
            
            function handleReset() {
                if (simState && simState.mission) {
                    simState.mission.distanceCoveredMeters = 0;
                    simState.mission.lostConnection = false;
                }
                simState.simulation.paused = false;
                simState.simulation.aborted = false;
                pauseButton.textContent = 'PAUSE';
                setStatus('STANDBY', 'red', true);
                logMessage('Simulation reset.');
                init();
            }

            function resizeCanvas() {
                const dpr = window.devicePixelRatio || 1;
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
                canvas.style.width = rect.width + 'px';
                canvas.style.height = rect.height + 'px';
                ctx.scale(dpr, dpr);
            }

            // --- Gemini API Functions for Mission Report ---
            
            /**
             * Exponential backoff utility for fetching.
             */
            async function exponentialBackoffFetch(url, options, retries = 5, delay = 1000) {
                for (let i = 0; i < retries; i++) {
                    try {
                        const response = await fetch(url, options);
                        if (!response.ok) {
                            // Non-retryable errors (400, 401, 403)
                            if (response.status === 400 || response.status === 401 || response.status === 403) {
                                const errorJson = await response.json();
                                throw new Error(errorJson.error.message || `API failed with status ${response.status}`);
                            }
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response;
                    } catch (error) {
                        if (i === retries - 1) {
                            console.error("Fetch failed after all retries:", error);
                            throw error;
                        }
                        await new Promise(resolve => setTimeout(resolve, delay * (2 ** i) + Math.random() * 1000));
                    }
                }
            }


            /**
             * Generates a structured mission report using the Gemini API.
             */
            async function generateMissionReport() {
                if (!simState.launched || simState.running) return;

                generateReportButton.disabled = true;
                generateReportButton.textContent = "ANALYZING...";
                reportContent.innerHTML = '<p class="text-center text-gray-400 py-8"><svg class="animate-spin h-5 w-5 mr-3 inline-block text-cyan-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg> Generating complex mission report...</p>';
                reportModal.classList.remove('hidden');                const totalDuration = simState.flightData.time.length > 0 ? parseFloat(simState.flightData.time[simState.flightData.time.length - 1]) : 0;

                let finalStatus;
                let flightEndedSuccessfully = false;

                if (simState.crash.crashed) {
                    finalStatus = "Crashed";
                } else if (simState.simulation.aborted) {
                    finalStatus = "Aborted";
                } else if (simState.mission.landing.state === 'landed') {
                    finalStatus = "Landed Successfully";
                    flightEndedSuccessfully = true;
                } else if (simState.mission.lostConnection) {
                    finalStatus = "Lost Connection in Space";
                } else if (simState.mission.uncontrolled) {
                    finalStatus = "Uncontrolled Descent (Fuel Depleted in Atmosphere)";
                } else {
                    finalStatus = "Simulation Ended (Unknown Reason)"; // Fallback for other non-running states
                }
                const maxVelocity = simState.flightData.velocity.reduce((max, v) => Math.max(max, v), 0);
                
                // Summarize staging events
                const stagingSummary = simState.rocket.stages.map((stage, index) => ({
                    stageIndex: index + 1,
                    name: stage.name,
                    separated: stage.separated,
                    // Only report remaining fuel if it was separated or the flight ended while it was active
                    fuelRemaining: stage.separated || (index === simState.rocket.currentStage && !simState.running) ? stage.fuelMass.toFixed(0) : 'N/A'
                }));

                // Construct the detailed prompt and system instruction
                const missionData = {
                    rocketName: selectedRocketBlueprint.name,
                    finalStatus: finalStatus,
                    durationSeconds: totalDuration,
                    maxAltitudeMeters: simState.stats.maxAltitude.toFixed(2),
                    maxVelocityMetersPerSecond: maxVelocity.toFixed(2),
                    finalTWR: (simState.rocket.totalMass > 0 ? (simState.rocket.stages.filter(s=>s.active).reduce((sum, s) => sum + s.maxThrust * simState.rocket.throttle, 0) / (simState.rocket.totalMass * G)) : 0).toFixed(2),
                    isCrashed: simState.crash.crashed,                    flightEndedSuccessfully: flightEndedSuccessfully,
                    stagingEvents: stagingSummary,
                };

                const systemPrompt = "You are a highly experienced aerospace engineer specializing in post-flight analysis. Your task is to analyze the provided mission data and generate a structured JSON report. The analysis should be concise, professional, and focus on physical performance, success factors, and clear recommendations. The overall mission goal is to achieve orbital velocity and altitude (not simulated here, but use the data to comment on potential readiness). Do not use markdown inside the text fields.";
                
                const userQuery = `Analyze the following rocket launch mission data and generate a structured report. Simulation data: ${JSON.stringify(missionData)}`;

                const responseSchema = {
                    type: "OBJECT",
                    properties: {
                        missionTitle: { type: "STRING", description: "A concise, professional title for the report." },
                        outcomeSummary: { type: "STRING", description: "A single paragraph summarizing the flight outcome (success, failure, or partial success) and the reason the simulation ended." },
                        performanceMetrics: {
                            type: "OBJECT",
                            properties: {
                                maxAltitude: { type: "STRING", description: "Reported Max Altitude (e.g., 50.12 km)" },
                                maxVelocity: { type: "STRING", description: "Reported Max Velocity (e.g., 1.5 km/s)" },
                                duration: { type: "STRING", description: "Total Flight Duration (e.g., 150 seconds)" },
                            },
                        },
                        keyFindings: {
                            type: "ARRAY",
                            items: { type: "STRING" },
                            description: "A bulleted list of 3-5 key observations about the flight performance (e.g., early staging, low thrust-to-weight ratio)."
                        },
                        recommendations: {
                            type: "STRING",
                            description: "A paragraph of specific, actionable advice for the next flight attempt to improve performance or avoid the identified issues."
                        }
                    },
                    required: ["missionTitle", "outcomeSummary", "performanceMetrics", "keyFindings", "recommendations"],
                };

                try {
                    const payload = {
                        contents: [{ parts: [{ text: userQuery }] }],
                        systemInstruction: { parts: [{ text: systemPrompt }] },
                        generationConfig: {
                            responseMimeType: "application/json",
                            responseSchema: responseSchema
                        }
                    };

                    const response = await exponentialBackoffFetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    const result = await response.json();
                    const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;
                    
                    if (!jsonText) {
                        throw new Error("Gemini API returned no text content.");
                    }

                    const report = JSON.parse(jsonText);
                    
                    displayReport(report);

                } catch (error) {
                    logMessage(`Report Generation Failed: ${error.message}`);
                    console.error("Gemini API Error:", error);
                    reportContent.innerHTML = `<p class="text-red-400 text-center py-4">Error generating report: ${error.message || 'Check console for details.'}</p>`;
                } finally {
                    generateReportButton.disabled = false;
                    generateReportButton.textContent = "GENERATE REPORT âœ¨";
                }
            }

            /**
             * Renders the structured report JSON into the modal UI.
             */
            function displayReport(report) {
                const kmAlt = (parseFloat(report.performanceMetrics.maxAltitude) / 1000).toFixed(2);
                const kmVel = (parseFloat(report.performanceMetrics.maxVelocity) / 1000).toFixed(2);

                let html = `
                    <div class="bg-gray-900 p-4 rounded-lg border border-gray-700">
                        <h3 class="text-xl font-bold text-green-400 font-orbitron mb-1">${report.missionTitle}</h3>
                        <p class="text-sm text-gray-500">Analysis complete by Gemini Aerospace Analyst.</p>
                    </div>

                    <h3 class="text-lg font-bold text-cyan-400 mt-4">1. Outcome Summary</h3>
                    <p>${report.outcomeSummary}</p>
                    
                    <h3 class="text-lg font-bold text-cyan-400 mt-4">2. Performance Metrics</h3>
                    <div class="grid grid-cols-3 gap-4 text-center bg-gray-900/50 p-3 rounded-lg">
                        <div>
                            <span class="text-sm text-gray-400 block">Max Altitude</span>
                            <span class="text-xl font-orbitron text-white">${kmAlt} km</span>
                        </div>
                        <div>
                            <span class="text-sm text-gray-400 block">Max Velocity</span>
                            <span class="text-xl font-orbitron text-white">${kmVel} km/s</span>
                        </div>
                        <div>
                            <span class="text-sm text-gray-400 block">Flight Duration</span>
                            <span class="text-xl font-orbitron text-white">${report.performanceMetrics.duration}</span>
                        </div>
                    </div>

                    <h3 class="text-lg font-bold text-cyan-400 mt-4">3. Key Findings</h3>
                    <ul class="list-disc list-inside space-y-1 ml-4">
                        ${report.keyFindings.map(f => `<li>${f}</li>`).join('')}
                    </ul>

                    <h3 class="text-lg font-bold text-cyan-400 mt-4">4. Recommendations</h3>
                    <p>${report.recommendations}</p>
                `;
                reportContent.innerHTML = html;
            }


            ignitionButton.addEventListener('click', handleIgnition);
            stageButton.addEventListener('click', () => handleStageSeparation(false)); // Manual staging
            resetButton.addEventListener('click', handleReset);
            throttleSlider.addEventListener('input', handleThrottleChange);
            

            timeScaleSlider.addEventListener('input', handleTimeScaleChange);
            zoomSlider.addEventListener('input', handleZoomChange);
            engineShutdownButton.addEventListener('click', handleEngineShutdown);
            abortButton.addEventListener('click', handleAbort);
            pauseButton.addEventListener('click', handlePause);            function handleLandingKeys(e){
                // All interactive landing controls (including throttle/engine via keyboard) have been removed for a streamlined auto-landing experience.
                // General simulation controls like pause/reset are handled by their respective UI buttons.
            }
            // The listener for handleLandingKeys remains active, but the function body is now empty for landing-specific keys.

            // Landing handlers
            function handleToggleAutoLand(e){
                if (!simState || !simState.mission) return;
                simState.mission.landing.autoEnabled = !!e.target.checked;
                if (!simState.mission.landing.autoEnabled && simState.mission.arrived && simState.mission.landing.state !== 'landed') {
                    // If auto-land is disabled while already arrived and not landed, transition to hold (approach)
                    simState.mission.landing.state = 'approach';
                    setStatus('APPROACH HOLD', 'yellow', true);
                    logMessage('Auto-land disabled. Holding at destination.');
                } else if (simState.mission.landing.autoEnabled && simState.mission.arrived && simState.mission.landing.state === 'approach') {
                    // If auto-land is enabled while holding, start the countdown
                    simState.mission.landing.countdownEndTime = performance.now() + 5000;
                    simState.mission.landing.state = 'countdown';
                    setStatus('APPROACH HOLD', 'yellow', true);
                    logMessage('Auto-descent initiated from hold. Commencing in 5s...');
                }
            }
            autoLandCheckbox.addEventListener('change', handleToggleAutoLand);
            // Removed event listeners for landAutoBtn, landManualBtn, landHoldBtn.

            // New Custom Builder elements
            const customBuilderModal = document.getElementById('custom-builder-modal');
            const openCustomBuilderBtn = document.getElementById('open-custom-builder-btn');
            const closeCustomBuilderBtn = document.getElementById('close-custom-builder-btn');
            const customRocketNameInput = document.getElementById('custom-rocket-name');
            const customPayloadMassInput = document.getElementById('custom-payload-mass');
            const customStagesContainer = document.getElementById('custom-stages-container');
            const addStageBtn = document.getElementById('add-stage-btn');
            const saveAndLaunchBtn = document.getElementById('save-and-launch-btn');
            const analyzeRocketBtn = document.getElementById('analyze-rocket-btn');
            const aiSuggestionText = document.getElementById('ai-suggestion-text');

            // New AI event listeners
            generateReportButton.addEventListener('click', generateMissionReport);
            closeReportModal.addEventListener('click', () => {
                reportModal.classList.add('hidden');
            });

            // Custom Builder event listeners
            openCustomBuilderBtn.addEventListener('click', () => {
                customBuilderModal.classList.remove('hidden');
                if (customRocketStages.length === 0) {
                    addDefaultStage();
                } else {
                    renderCustomStages();
                }
            });
            // Also allow clicking the entire card
            document.getElementById('create-custom-rocket-card').addEventListener('click', () => {
                customBuilderModal.classList.remove('hidden');
                if (customRocketStages.length === 0) {
                    addDefaultStage();
                } else {
                    renderCustomStages();
                }
            });
            closeCustomBuilderBtn.addEventListener('click', () => {
                customBuilderModal.classList.add('hidden');
            });
            addStageBtn.addEventListener('click', addDefaultStage);
            saveAndLaunchBtn.addEventListener('click', () => {
                const customData = getCustomRocketData();
                if (customData.stages.length === 0) {
                    alert('Please add at least one stage.');
                    return;
                }
                selectedRocketBlueprint = customData;
                customBuilderModal.classList.add('hidden');
                hangarDashboard.classList.add('hidden');
                init();
            });
            analyzeRocketBtn.addEventListener('click', analyzeRocketForTWR);

            window.addEventListener('resize', resizeCanvas);

            // Render the hangar dashboard initially
            renderHangarDashboard();
        });
    </script>
</body>
</html>
